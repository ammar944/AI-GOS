---
phase: 21-integration-tests
plan: 02
type: execute
---

<objective>
Integration tests for API route handlers verifying request validation, error responses, and pipeline orchestration with mocked dependencies.

Purpose: Ensure API routes handle all input variations correctly and return appropriate HTTP responses.
Output: Integration tests for media-plan generate, chat blueprint, and health endpoints with ~25-30 tests.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Prior plan in this phase:**
@.planning/phases/21-integration-tests/21-01-SUMMARY.md

**Codebase constraints:**
- Next.js App Router API routes (Request/Response pattern)
- Vitest 4.0 with jsdom environment
- Mock pipeline functions, not OpenRouter directly (test route logic, not AI)

**Source files:**
@src/app/api/media-plan/generate/route.ts
@src/app/api/chat/blueprint/route.ts
@src/app/api/chat/blueprint/stream/route.ts
@src/app/api/health/route.ts
@src/test/mocks/openrouter.ts
@src/test/factories/media-plan.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Media plan generate route tests</name>
  <files>src/app/api/media-plan/generate/__tests__/route.test.ts</files>
  <action>
Create integration tests for POST /api/media-plan/generate:

**Validation tests:**
- Returns 400 for missing request body
- Returns 400 for missing niche data
- Returns 400 for invalid niche data (empty strings)
- Returns 400 for missing briefing data
- Returns 400 for invalid briefing data (budget <= 0, invalid salesCycleLength)
- Returns 400 for non-object body

**Success tests:**
- Returns 200 with blueprint for valid input (mock runMediaPlanPipeline)
- Response includes success: true and blueprint object

**Error tests:**
- Returns 500 when pipeline fails (mock failure)
- Returns 504 when pipeline times out (mock timeout)
- Error response includes success: false and error message

**GET method test:**
- Returns 200 with API info message

Mock strategy:
- vi.mock('@/lib/media-plan/pipeline') to mock runMediaPlanPipeline
- Use factory functions from 21-01 for test data
- Create Request objects with JSON body

Test helper:
```typescript
async function callRoute(body: unknown) {
  const request = new Request('http://test/api/media-plan/generate', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(body),
  });
  return POST(request);
}
```
  </action>
  <verify>npm test src/app/api/media-plan/generate/__tests__/route.test.ts passes</verify>
  <done>~15 tests covering validation, success, and error scenarios for generate route</done>
</task>

<task type="auto">
  <name>Task 2: Chat blueprint route tests</name>
  <files>src/app/api/chat/blueprint/__tests__/route.test.ts</files>
  <action>
Create integration tests for POST /api/chat/blueprint:

**Validation tests:**
- Returns 400 for missing blueprintId
- Returns 400 for missing message
- Returns 400 for empty message string

**Intent routing tests (mock classifyIntent):**
- Routes 'question' intent to Q&A agent
- Routes 'edit' intent to Edit agent
- Routes 'explain' intent to Explain agent
- Routes 'general' intent to Q&A agent (fallback)

**Response format tests:**
- Returns JSON with assistant message for non-streaming
- Edit intent returns pendingEdit object
- Explain intent returns explanation with sources

**Error tests:**
- Returns 500 when intent classification fails
- Returns 500 when agent execution fails
- Error includes meaningful message

Mock strategy:
- vi.mock('@/lib/chat/intent-router') for classifyIntent
- vi.mock('@/lib/chat/agents/qa-agent') for Q&A
- vi.mock('@/lib/chat/agents/edit-agent') for Edit
- vi.mock('@/lib/chat/agents/explain-agent') for Explain
  </action>
  <verify>npm test src/app/api/chat/blueprint/__tests__/route.test.ts passes</verify>
  <done>~12 tests covering validation, intent routing, and error handling for chat route</done>
</task>

<task type="auto">
  <name>Task 3: Health endpoint and streaming route tests</name>
  <files>src/app/api/health/__tests__/route.test.ts, src/app/api/chat/blueprint/stream/__tests__/route.test.ts</files>
  <action>
**Health endpoint tests (src/app/api/health/__tests__/route.test.ts):**
- Returns 200 with status 'ok' when all services healthy
- Returns 200 with status 'degraded' when optional services unavailable
- Response includes timestamp
- Response includes version info

**Streaming route tests (src/app/api/chat/blueprint/stream/__tests__/route.test.ts):**
- Returns 400 for missing required fields
- Returns correct Content-Type header (text/event-stream)
- Streams SSE format data chunks
- Handles stream errors gracefully
- Terminates stream on completion

Mock strategy for streaming:
- Mock the streaming chat method to yield test chunks
- Verify ReadableStream behavior
- Test SSE event format: "data: {json}\n\n"
  </action>
  <verify>npm test src/app/api/health/__tests__/route.test.ts && npm test src/app/api/chat/blueprint/stream/__tests__/route.test.ts passes</verify>
  <done>~10 tests total for health and streaming endpoints</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm test -- --run` passes all tests (no regressions)
- [ ] API route tests verify HTTP status codes and response shapes
- [ ] Validation edge cases covered (empty strings, wrong types, missing fields)
- [ ] Error responses follow consistent format
- [ ] No TypeScript errors
</verification>

<success_criteria>
- All tasks completed
- ~25-30 new API route integration tests
- All routes have validation, success, and error test coverage
- Tests don't require actual API calls (fully mocked)
</success_criteria>

<output>
After completion, create `.planning/phases/21-integration-tests/21-02-SUMMARY.md`
</output>
