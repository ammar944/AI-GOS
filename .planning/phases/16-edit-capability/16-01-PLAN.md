---
phase: 16-edit-capability
plan: 01
type: execute
---

<objective>
Add intent classification to the chat system, enabling the API to distinguish between questions, edits, explanations, and regeneration requests.

Purpose: The intent router is the dispatcher that routes user messages to appropriate agents. Without it, all messages go to Q&A.
Output: Intent types, intent router service, updated chat API with dispatch logic.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/docs/Blueprint_AI_Chat_RAG_Specification_OpenRouter.md

**Prior phase deliverables (Phase 15):**
@src/lib/chat/types.ts
@src/lib/chat/retrieval.ts
@src/lib/chat/agents/qa-agent.ts
@src/app/api/blueprint/[id]/chat/route.ts

**OpenRouter client:**
@src/lib/openrouter/client.ts

**Prior decisions affecting this phase:**
- Temperature 0.3 for Q&A (consistent responses) - use similar for intent classification
- Claude Sonnet for Q&A agent - use Claude Haiku for intent classification (fast, cheap)
- Match threshold 0.65 for retrieval - maintain for edit context retrieval
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Intent types to chat types</name>
  <files>src/lib/chat/types.ts</files>
  <action>
Add ChatIntent union type with discriminated unions for each intent:
- `question`: { type: 'question'; topic: string; sections: string[] }
- `edit`: { type: 'edit'; section: string; field: string; desiredChange: string }
- `explain`: { type: 'explain'; section: string; field: string; whatToExplain: string }
- `regenerate`: { type: 'regenerate'; section: string; instructions: string }
- `general`: { type: 'general'; topic: string }

Add IntentClassificationResult interface for the router response.
  </action>
  <verify>npx tsc --noEmit passes with no errors on types.ts</verify>
  <done>ChatIntent union type exported, all intent variants typed</done>
</task>

<task type="auto">
  <name>Task 2: Create Intent Router service</name>
  <files>src/lib/chat/intent-router.ts</files>
  <action>
Create intent-router.ts that:
1. Exports classifyIntent(message: string): Promise<ChatIntent>
2. Uses createOpenRouterClient() with MODELS.CLAUDE_SONNET (Haiku not available, Sonnet is fast enough)
3. System prompt describes the 5 blueprint sections and intent types
4. Uses jsonMode: true for reliable JSON output
5. Temperature 0 for deterministic classification
6. maxTokens: 256 (classification is short)
7. Parses response and returns typed ChatIntent

System prompt should list:
- industryMarketOverview: Market landscape, pain points, psychological drivers
- icpAnalysisValidation: ICP viability, reachability, pain-solution fit
- offerAnalysisViability: Offer strength scores, red flags, recommendations
- competitorAnalysis: Competitor profiles, ad hooks, funnel patterns
- crossAnalysisSynthesis: Key insights, positioning, messaging angles, next steps

Return cost and usage alongside intent for tracking.
  </action>
  <verify>npx tsc --noEmit passes, intent-router.ts exports classifyIntent</verify>
  <done>Intent router classifies messages into 5 intent types with cost tracking</done>
</task>

<task type="auto">
  <name>Task 3: Update chat API with intent routing</name>
  <files>src/app/api/blueprint/[id]/chat/route.ts</files>
  <action>
Update the chat endpoint to:
1. Import classifyIntent from intent-router
2. First call classifyIntent(message) to get intent
3. Add intent to response type (ChatResponse.intent)
4. For now, only handle 'question' and 'general' intents (edit/explain/regenerate in later plans)
5. For 'edit', 'explain', 'regenerate' - return placeholder message: "Edit/Explain/Regenerate capability coming soon. For now, I can answer questions about your blueprint."
6. Track intent classification cost in metadata.cost
7. Add intent to response for frontend visibility

Update ChatResponse interface to include:
- intent: ChatIntent
- pendingAction?: unknown (placeholder for edit confirmation flow)
  </action>
  <verify>npx tsc --noEmit passes, API compiles without errors</verify>
  <done>Chat API routes messages through intent classifier, returns intent in response</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx tsc --noEmit` succeeds without errors
- [ ] Intent types properly discriminated (type field distinguishes variants)
- [ ] Intent router returns valid ChatIntent for test messages
- [ ] Chat API includes intent in response
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors
- Intent classification working for all 5 intent types
- Chat API dispatches based on intent (question vs placeholder for others)
</success_criteria>

<output>
After completion, create `.planning/phases/16-edit-capability/16-01-SUMMARY.md`
</output>
