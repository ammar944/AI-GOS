---
phase: 16-edit-capability
plan: 03
type: execute
---

<objective>
Complete the edit flow with confirmation API endpoint and UI components for reviewing and confirming proposed edits.

Purpose: Users must review and approve edits before they're applied. This plan delivers the confirmation flow.
Output: confirm-edit API endpoint, EditConfirmation component, updated BlueprintChat with edit handling.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/docs/Blueprint_AI_Chat_RAG_Specification_OpenRouter.md

**Prior plan deliverables (16-01, 16-02):**
@src/lib/chat/types.ts
@src/lib/chat/intent-router.ts
@src/lib/chat/agents/edit-agent.ts

**Existing chat UI:**
@src/components/chat/blueprint-chat.tsx
@src/components/chat/chat-message.tsx

**Chat API:**
@src/app/api/blueprint/[id]/chat/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create confirm-edit API endpoint</name>
  <files>src/app/api/blueprint/[id]/confirm-edit/route.ts</files>
  <action>
Create POST /api/blueprint/[id]/confirm-edit endpoint:

1. Define request/response types:
```typescript
interface ConfirmEditRequest {
  conversationId: string;
  editResult: {
    section: string;
    fieldPath: string;
    oldValue: unknown;
    newValue: unknown;
    explanation: string;
  };
  confirmed: boolean;
}

interface ConfirmEditResponse {
  success: boolean;
  versionId?: string;
  versionNumber?: number;
  message: string;
}
```

2. If not confirmed, return { success: true, message: 'Edit cancelled' }

3. If confirmed:
- Call supabase.rpc('apply_blueprint_edit', { ... }) with edit details
- Re-chunk the affected section (call rechunkSection helper)
- Return { success: true, versionId, message: 'Edit applied successfully' }

4. Add rechunkSection helper that:
- Fetches updated blueprint section
- Deletes old chunks for that section
- Re-chunks and stores new embeddings
- Uses existing chunking/embedding services from Phase 15

5. Handle errors with proper status codes (400 for bad request, 500 for server error)
  </action>
  <verify>npx tsc --noEmit passes, endpoint compiles without errors</verify>
  <done>confirm-edit API applies or cancels edits, re-chunks affected sections</done>
</task>

<task type="auto">
  <name>Task 2: Update chat API to handle edit intent</name>
  <files>src/app/api/blueprint/[id]/chat/route.ts</files>
  <action>
Update chat endpoint to fully handle edit intents:

1. Import handleEdit from edit-agent
2. Add helper to fetch full section data for edit context:
```typescript
async function fetchFullSection(blueprintId: string, section: string) {
  const supabase = await createClient();
  const { data } = await supabase
    .from('blueprints')
    .select('output')
    .eq('id', blueprintId)
    .single();
  return data?.output?.[section] || null;
}
```

3. For intent.type === 'edit':
- Fetch full section using fetchFullSection(blueprintId, intent.section)
- Call handleEdit({ fullSection, intent, chatHistory })
- Format response message with diff preview
- Set pendingAction to the EditResult
- Response should say: "I'll make this change:\n\n**Field:** {fieldPath}\n**Change:** {explanation}\n\n{diffPreview}\n\nReply 'confirm' to apply or 'cancel' to discard."

4. Add pendingAction to ChatResponse type (already placeholder from 16-01)

5. Track total cost including intent classification + edit agent
  </action>
  <verify>npx tsc --noEmit passes, edit intent returns pendingAction with EditResult</verify>
  <done>Chat API handles edit intent, returns pending action for confirmation</done>
</task>

<task type="auto">
  <name>Task 3: Update BlueprintChat for edit confirmation flow</name>
  <files>src/components/chat/blueprint-chat.tsx, src/components/chat/chat-message.tsx</files>
  <action>
Update chat components to handle edit confirmation:

1. In BlueprintChat:
- Add state: pendingEdit (EditResult | null)
- When response includes pendingAction with edit, store in pendingEdit
- Add confirmation UI below messages when pendingEdit exists:
  - Show diff preview in a styled box (bg-muted, monospace font)
  - "Confirm" button (primary) calls confirm-edit API with confirmed: true
  - "Cancel" button (outline) calls confirm-edit API with confirmed: false
- After confirm/cancel: clear pendingEdit, add result message to chat

2. In chat-message.tsx:
- Add visual indicator for edit proposals (different styling, edit icon)
- Show diff preview in code-style block

3. Confirmation UI structure:
```tsx
{pendingEdit && (
  <div className="border rounded-lg p-4 bg-muted/50">
    <div className="text-sm font-medium mb-2">Proposed Edit</div>
    <div className="text-xs text-muted-foreground mb-2">
      {pendingEdit.section} / {pendingEdit.fieldPath}
    </div>
    <pre className="text-xs bg-background p-2 rounded mb-3 overflow-auto">
      {pendingEdit.diffPreview}
    </pre>
    <div className="flex gap-2">
      <Button size="sm" onClick={handleConfirm}>Confirm Edit</Button>
      <Button size="sm" variant="outline" onClick={handleCancel}>Cancel</Button>
    </div>
  </div>
)}
```

4. Add loading state during confirmation API call
  </action>
  <verify>npx tsc --noEmit passes, components render without errors</verify>
  <done>BlueprintChat displays edit proposals with confirm/cancel flow</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete edit capability flow: intent classification -> edit agent -> confirmation UI -> apply edit</what-built>
  <how-to-verify>
    1. Run: npm run dev
    2. Navigate to a blueprint with chat open
    3. Type an edit request like "Change the positioning to focus on speed and efficiency"
    4. Verify: Chat shows edit proposal with diff preview
    5. Verify: Confirm/Cancel buttons appear below the proposal
    6. Click Confirm and verify: Edit is applied, confirmation message shown
    7. Check blueprint data reflects the change
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx tsc --noEmit` succeeds without errors
- [ ] `npm run build` succeeds
- [ ] Edit requests show diff preview in chat
- [ ] Confirm button applies edit and updates blueprint
- [ ] Cancel button discards edit without changes
- [ ] Re-chunking happens after edit is applied
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Human verification approved
- Complete edit flow working end-to-end
- Phase 16 Edit Capability complete
</success_criteria>

<output>
After completion, create `.planning/phases/16-edit-capability/16-03-SUMMARY.md`

This summary should note:
- Phase 16 complete
- Ready for Phase 17: Explain Agent
</output>
