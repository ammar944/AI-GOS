---
phase: 16-edit-capability
plan: 02
type: execute
---

<objective>
Create the Edit Agent that interprets natural language edit requests and generates proposed changes, plus database infrastructure for version history.

Purpose: The Edit Agent is the core of edit capability - it understands what the user wants to change and generates the diff.
Output: Edit agent service, version history table, apply_blueprint_edit RPC function.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/docs/Blueprint_AI_Chat_RAG_Specification_OpenRouter.md

**Prior plan deliverables (16-01):**
@src/lib/chat/types.ts
@src/lib/chat/intent-router.ts

**Existing infrastructure:**
@src/lib/chat/retrieval.ts
@src/lib/chat/agents/qa-agent.ts
@src/lib/openrouter/client.ts

**Prior decisions affecting this phase:**
- Temperature 0.3 for consistent responses - use 0.2 for edit precision
- Claude Sonnet for agents - continue pattern
- SECURITY DEFINER for RPC functions (from 15-01)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Edit Agent service</name>
  <files>src/lib/chat/agents/edit-agent.ts</files>
  <action>
Create edit-agent.ts that:

1. Define EditResult interface:
```typescript
interface EditResult {
  section: BlueprintSection;
  fieldPath: string;
  oldValue: unknown;
  newValue: unknown;
  explanation: string;
  diffPreview: string;
  requiresConfirmation: true;
}
```

2. Export handleEdit(context: EditContext): Promise<EditResponse> where:
- EditContext includes: fullSection (current section data), intent (ChatIntent with type='edit'), chatHistory
- EditResponse includes: result: EditResult, usage, cost

3. System prompt instructs Claude to:
- Identify exact field to edit based on user request
- Generate new value matching original data type
- Explain why the change addresses the request
- Return JSON with fieldPath, oldValue, newValue, explanation

4. Use createOpenRouterClient() with MODELS.CLAUDE_SONNET
- temperature: 0.2 (precision for edits)
- maxTokens: 2048
- jsonMode: true

5. Add generateDiffPreview(oldValue, newValue) helper that creates readable diff string

6. Always set requiresConfirmation: true (edits need user approval)
  </action>
  <verify>npx tsc --noEmit passes, edit-agent.ts exports handleEdit</verify>
  <done>Edit agent interprets edit requests, returns EditResult with diff preview</done>
</task>

<task type="auto">
  <name>Task 2: Create version history database infrastructure</name>
  <files>supabase/migrations/20260107_blueprint_versions.sql</files>
  <action>
Apply migration via Supabase MCP that creates:

1. blueprint_versions table:
```sql
CREATE TABLE blueprint_versions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  blueprint_id UUID NOT NULL REFERENCES blueprints(id) ON DELETE CASCADE,
  version_number INTEGER NOT NULL,
  change_type TEXT NOT NULL CHECK (change_type IN ('edit', 'regenerate', 'revert')),
  change_summary TEXT NOT NULL,
  changes JSONB NOT NULL,  -- { fieldPath, oldValue, newValue }
  changed_by TEXT NOT NULL CHECK (changed_by IN ('user', 'ai_chat')),
  conversation_id UUID,
  full_snapshot JSONB NOT NULL,  -- Complete blueprint state at this version
  created_at TIMESTAMPTZ DEFAULT NOW()
);
```

2. Indexes:
- idx_blueprint_versions_blueprint ON blueprint_versions(blueprint_id, version_number DESC)
- UNIQUE idx_blueprint_versions_unique ON blueprint_versions(blueprint_id, version_number)

3. get_next_version_number(p_blueprint_id UUID) function that returns next version number

Use mcp__supabase__apply_migration with project_id from environment or ask user.
  </action>
  <verify>Migration applied successfully, table exists in Supabase</verify>
  <done>blueprint_versions table created with indexes and version number function</done>
</task>

<task type="auto">
  <name>Task 3: Create apply_blueprint_edit RPC function</name>
  <files>supabase/migrations/20260107_apply_blueprint_edit.sql</files>
  <action>
Apply migration that creates apply_blueprint_edit RPC:

```sql
CREATE OR REPLACE FUNCTION apply_blueprint_edit(
  p_blueprint_id UUID,
  p_section TEXT,
  p_field_path TEXT,
  p_new_value JSONB,
  p_old_value JSONB,
  p_change_summary TEXT,
  p_conversation_id UUID DEFAULT NULL
)
RETURNS UUID
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_current_output JSONB;
  v_new_output JSONB;
  v_version_number INTEGER;
  v_version_id UUID;
BEGIN
  -- Get current blueprint output
  SELECT output INTO v_current_output
  FROM blueprints
  WHERE id = p_blueprint_id;

  IF v_current_output IS NULL THEN
    RAISE EXCEPTION 'Blueprint not found: %', p_blueprint_id;
  END IF;

  -- Apply edit using jsonb_set with path
  -- Note: field_path like "recommendedPositioning" or "painPoints.primary[0]"
  v_new_output := jsonb_set(
    v_current_output,
    string_to_array(p_section || '.' || p_field_path, '.'),
    p_new_value
  );

  -- Get next version number
  SELECT get_next_version_number(p_blueprint_id) INTO v_version_number;

  -- Create version record
  INSERT INTO blueprint_versions (
    blueprint_id, version_number, change_type, change_summary,
    changes, changed_by, conversation_id, full_snapshot
  ) VALUES (
    p_blueprint_id, v_version_number, 'edit', p_change_summary,
    jsonb_build_object(
      'section', p_section,
      'fieldPath', p_field_path,
      'oldValue', p_old_value,
      'newValue', p_new_value
    ),
    'ai_chat', p_conversation_id, v_current_output
  ) RETURNING id INTO v_version_id;

  -- Update blueprint
  UPDATE blueprints
  SET output = v_new_output, updated_at = NOW()
  WHERE id = p_blueprint_id;

  RETURN v_version_id;
END;
$$;
```

This function:
1. Gets current blueprint output
2. Applies the edit using jsonb_set
3. Creates version record with snapshot of previous state
4. Updates blueprint with new output
5. Returns the version ID
  </action>
  <verify>RPC function created, can be called from Supabase client</verify>
  <done>apply_blueprint_edit RPC applies edits atomically with version tracking</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx tsc --noEmit` succeeds without errors
- [ ] Edit agent returns properly structured EditResult
- [ ] blueprint_versions table exists in database
- [ ] apply_blueprint_edit RPC function exists and is callable
- [ ] get_next_version_number returns incrementing numbers
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors
- Edit agent generates accurate field identification and diffs
- Database supports atomic edits with version history
</success_criteria>

<output>
After completion, create `.planning/phases/16-edit-capability/16-02-SUMMARY.md`
</output>
