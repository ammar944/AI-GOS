---
phase: 04-error-reporting
plan: 01
type: execute
---

<objective>
Add structured error responses with error codes and contextual logging across all generation API routes.

Purpose: Enable precise error identification for debugging and provide machine-readable error codes for frontend handling.
Output: Typed error response format, error codes enum, structured logging with request context.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Prior decisions affecting this plan:**
- Phase 02-02: `failureReason` categorization exists (timeout, circuit_open, validation, api_error, unknown)
- Phase 03-01: Health endpoint pattern for structured responses

**Relevant source files:**
@src/app/api/media-plan/generate/route.ts
@src/app/api/media-plan/full-plan/route.ts
@src/app/api/strategic-blueprint/generate/route.ts
@src/lib/media-plan/pipeline/media-plan-generator.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create error types utility with codes and structured response</name>
  <files>src/lib/errors.ts</files>
  <action>
Create a new error types utility file:

1. Define `ErrorCode` enum with specific codes:
   - `TIMEOUT` = "TIMEOUT" (section/request timeout)
   - `RATE_LIMITED` = "RATE_LIMITED" (OpenRouter rate limit)
   - `CIRCUIT_OPEN` = "CIRCUIT_OPEN" (circuit breaker tripped)
   - `VALIDATION_FAILED` = "VALIDATION_FAILED" (schema validation)
   - `PARSE_ERROR` = "PARSE_ERROR" (JSON extraction failed)
   - `API_ERROR` = "API_ERROR" (OpenRouter API error)
   - `INVALID_INPUT` = "INVALID_INPUT" (bad request data)
   - `INTERNAL_ERROR` = "INTERNAL_ERROR" (unknown/catch-all)

2. Define `ApiErrorResponse` interface:
   ```typescript
   interface ApiErrorResponse {
     success: false;
     error: {
       code: ErrorCode;
       message: string;
       details?: string;
       retryable: boolean;
       section?: string; // which section failed (for media plan)
       completedSections?: string[]; // for partial results
     };
   }
   ```

3. Create `createErrorResponse(code, message, options?)` helper function that:
   - Returns properly typed error response
   - Sets `retryable` based on code (TIMEOUT, RATE_LIMITED, CIRCUIT_OPEN = true)
   - Accepts optional section and completedSections for partial failure context

4. Create `mapFailureReasonToCode(failureReason)` helper to convert existing failureReason values to ErrorCode.
  </action>
  <verify>npx tsc --noEmit passes with new types</verify>
  <done>Error types file exists with ErrorCode enum, ApiErrorResponse interface, and helper functions</done>
</task>

<task type="auto">
  <name>Task 2: Add structured logging utility with request context</name>
  <files>src/lib/logger.ts</files>
  <action>
Create a lightweight logging utility:

1. Define `LogContext` interface:
   ```typescript
   interface LogContext {
     requestId?: string;
     route: string;
     method: string;
     timestamp: string;
     duration?: number;
     errorCode?: ErrorCode;
     section?: string;
     metadata?: Record<string, unknown>;
   }
   ```

2. Create `createRequestId()` function using crypto.randomUUID() or Date.now() + Math.random()

3. Create `logError(context: LogContext, error: Error | string)` function that:
   - Logs JSON-formatted output to console.error
   - Includes all context fields
   - Extracts error.message and error.stack if Error instance
   - Format: `[ERROR] ${JSON.stringify({...context, error: {...}})}`

4. Create `logInfo(context: Omit<LogContext, 'errorCode'>, message: string)` for success logging

5. Create `logWarn(context: LogContext, message: string)` for warnings (slow sections, retries)

Keep it simple - just structured console.log/error/warn. No external dependencies.
  </action>
  <verify>npx tsc --noEmit passes</verify>
  <done>Logger utility exists with structured JSON output functions</done>
</task>

<task type="auto">
  <name>Task 3: Update API routes to use structured error responses</name>
  <files>src/app/api/media-plan/full-plan/route.ts, src/app/api/strategic-blueprint/generate/route.ts</files>
  <action>
Update both generation routes to use the new error utilities:

1. Import `createErrorResponse`, `ErrorCode`, `mapFailureReasonToCode` from `@/lib/errors`
2. Import `logError`, `logInfo`, `createRequestId` from `@/lib/logger`

3. At start of POST handler:
   - Create requestId with `createRequestId()`
   - Create base logContext with route, method, timestamp

4. For validation errors (400):
   - Return `createErrorResponse(ErrorCode.INVALID_INPUT, "descriptive message")`

5. For generation failures:
   - Map result.metadata.failureReason to ErrorCode
   - Include result.metadata.completedSections in error response
   - Include result.failedSection
   - Log error with full context including request duration

6. For catch block errors:
   - Log error with stack trace
   - Return `createErrorResponse(ErrorCode.INTERNAL_ERROR, message)`

7. For success:
   - Log completion with duration and section count

8. Ensure status codes match:
   - INVALID_INPUT → 400
   - TIMEOUT, RATE_LIMITED → 503
   - CIRCUIT_OPEN → 503
   - VALIDATION_FAILED, PARSE_ERROR → 502
   - API_ERROR → 502
   - INTERNAL_ERROR → 500

Note: Leave /api/media-plan/generate route unchanged as it uses a different pipeline (runMediaPlanPipeline) that may have different error structure.
  </action>
  <verify>npm run build succeeds, no TypeScript errors</verify>
  <done>Both generation routes return structured error responses with codes, full context logging on errors and success</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx tsc --noEmit` passes
- [ ] `npm run build` succeeds
- [ ] src/lib/errors.ts exists with ErrorCode enum and helpers
- [ ] src/lib/logger.ts exists with structured logging functions
- [ ] API routes return `{success: false, error: {code, message, retryable, ...}}` on failure
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Error responses are structured with codes and retryable flag
- Logging includes request context and timing
</success_criteria>

<output>
After completion, create `.planning/phases/04-error-reporting/04-01-SUMMARY.md`
</output>
