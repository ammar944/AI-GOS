---
phase: 15-rag-foundation
plan: 02
type: execute
---

<objective>
Create embeddings and chunking services for RAG-powered Blueprint Chat.

Purpose: Enable conversion of blueprints into semantic chunks with vector embeddings for retrieval.
Output: Services for generating embeddings via OpenRouter and chunking blueprints for vector search.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-rag-foundation/DISCOVERY.md
@.planning/phases/15-rag-foundation/15-01-SUMMARY.md
@.planning/docs/Blueprint_AI_Chat_RAG_Specification_OpenRouter.md

**Codebase constraints:**
- Extend existing OpenRouterClient in src/lib/openrouter/client.ts
- Follow existing patterns for error handling (TimeoutError, APIError)
- Use existing MODELS constant pattern
- Supabase client patterns in src/lib/supabase/

**Prior decisions:**
- Use openai/text-embedding-3-small (1536 dimensions)
- IVFFlat index with 100 lists for vector search
- Chunk by semantic unit (individual pain points, competitors, etc.)

@src/lib/openrouter/client.ts
@src/lib/supabase/server.ts
@src/lib/strategic-blueprint/output-types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend OpenRouterClient with embeddings method</name>
  <files>src/lib/openrouter/client.ts</files>
  <action>
Add embeddings support to the existing OpenRouterClient:

1. Add EMBEDDING model to MODELS constant:
   ```typescript
   EMBEDDING: 'openai/text-embedding-3-small',
   ```

2. Add embedding cost to MODEL_COSTS:
   ```typescript
   [MODELS.EMBEDDING]: { input: 0.02, output: 0 },
   ```

3. Add EmbeddingOptions interface:
   ```typescript
   export interface EmbeddingOptions {
     model: string;
     input: string | string[];
     timeout?: number;
   }

   export interface EmbeddingResponse {
     embeddings: number[][];
     usage: {
       promptTokens: number;
       totalTokens: number;
     };
     cost: number;
   }
   ```

4. Add embeddings method to OpenRouterClient class:
   ```typescript
   async embeddings(options: EmbeddingOptions): Promise<EmbeddingResponse> {
     const { model, input, timeout = DEFAULT_TIMEOUT_MS } = options;

     // Same fetch pattern as chat() with AbortController
     // POST to /api/v1/embeddings
     // Response: { data: [{ index, embedding }], usage: { prompt_tokens, total_tokens } }
     // Return embeddings sorted by index
   }
   ```

Follow the same error handling patterns (TimeoutError, APIError) as the chat method.
  </action>
  <verify>
Create a simple test in a scratch file or use the TypeScript compiler to verify the method signature is correct:
`npx tsc --noEmit src/lib/openrouter/client.ts`
  </verify>
  <done>OpenRouterClient has embeddings() method that calls OpenRouter embeddings API</done>
</task>

<task type="auto">
  <name>Task 2: Create chunking service</name>
  <files>src/lib/chat/chunking.ts, src/lib/chat/types.ts</files>
  <action>
Create the chunking service following the specification's strategy:

1. Create src/lib/chat/types.ts with shared types:
   ```typescript
   export type BlueprintSection =
     | 'industryMarketOverview'
     | 'icpAnalysisValidation'
     | 'offerAnalysisViability'
     | 'competitorAnalysis'
     | 'crossAnalysisSynthesis';

   export interface ChunkInput {
     blueprintId: string;
     section: BlueprintSection;
     fieldPath: string;
     content: string;
     contentType: 'string' | 'number' | 'array' | 'object' | 'enum';
     metadata: {
       sectionTitle: string;
       fieldDescription: string;
       isEditable: boolean;
       originalValue: unknown;
     };
   }

   export interface BlueprintChunk extends ChunkInput {
     id: string;
     embedding: number[];
     similarity?: number;
     createdAt: Date;
     updatedAt: Date;
   }
   ```

2. Create src/lib/chat/chunking.ts with chunkBlueprint function:
   - Import StrategicBlueprintOutput from output-types.ts
   - Chunk each section following the spec's strategy:
     * industryMarketOverview: categorySnapshot as one, each painPoint individually, each driver individually, opportunities as array
     * icpAnalysisValidation: coherenceCheck, painSolutionFit, riskAssessment, finalVerdict separately
     * offerAnalysisViability: each score individually, redFlags as array, recommendation as object
     * competitorAnalysis: each competitor as one unit, adHooks as array, gapsAndOpportunities as object
     * crossAnalysisSynthesis: each keyInsight individually, positioning as one, messagingAngles as array, platforms as array, nextSteps as array
   - Return array of ChunkInput (without embeddings yet)

Key: Content should be human-readable text combining field name and value for better embedding quality.
  </action>
  <verify>
`npx tsc --noEmit src/lib/chat/chunking.ts`
  </verify>
  <done>chunkBlueprint() function converts StrategicBlueprintOutput into semantic chunks</done>
</task>

<task type="auto">
  <name>Task 3: Create embedding service with storage</name>
  <files>src/lib/chat/embeddings.ts</files>
  <action>
Create the embedding service that generates and stores embeddings:

1. Create src/lib/chat/embeddings.ts:

   ```typescript
   import { createOpenRouterClient, MODELS } from '@/lib/openrouter/client';
   import { createServerClient } from '@/lib/supabase/server';
   import { ChunkInput } from './types';

   /**
    * Generate embedding for a single text
    */
   export async function generateEmbedding(text: string): Promise<number[]> {
     const client = createOpenRouterClient();
     const response = await client.embeddings({
       model: MODELS.EMBEDDING,
       input: text,
     });
     return response.embeddings[0];
   }

   /**
    * Generate embeddings for multiple texts (batch)
    * More efficient than individual calls
    */
   export async function generateEmbeddings(texts: string[]): Promise<number[][]> {
     const client = createOpenRouterClient();
     const response = await client.embeddings({
       model: MODELS.EMBEDDING,
       input: texts,
     });
     return response.embeddings;
   }

   /**
    * Store chunks with embeddings in Supabase
    */
   export async function storeChunksWithEmbeddings(
     chunks: ChunkInput[]
   ): Promise<{ stored: number; cost: number }> {
     const client = createOpenRouterClient();
     const supabase = await createServerClient();

     // Generate all embeddings in batch
     const contents = chunks.map(c => c.content);
     const response = await client.embeddings({
       model: MODELS.EMBEDDING,
       input: contents,
     });

     // Prepare rows for insert (snake_case for DB)
     const rows = chunks.map((chunk, index) => ({
       blueprint_id: chunk.blueprintId,
       section: chunk.section,
       field_path: chunk.fieldPath,
       content: chunk.content,
       content_type: chunk.contentType,
       embedding: response.embeddings[index],
       metadata: chunk.metadata,
     }));

     // Batch insert
     const { error } = await supabase
       .from('blueprint_chunks')
       .insert(rows);

     if (error) {
       throw new Error(`Failed to store chunks: ${error.message}`);
     }

     return {
       stored: rows.length,
       cost: response.cost,
     };
   }

   /**
    * Delete all chunks for a blueprint (for re-chunking)
    */
   export async function deleteChunksForBlueprint(blueprintId: string): Promise<void> {
     const supabase = await createServerClient();
     const { error } = await supabase
       .from('blueprint_chunks')
       .delete()
       .eq('blueprint_id', blueprintId);

     if (error) {
       throw new Error(`Failed to delete chunks: ${error.message}`);
     }
   }
   ```

Ensure proper error handling and cost tracking.
  </action>
  <verify>
`npx tsc --noEmit src/lib/chat/embeddings.ts`
  </verify>
  <done>Embedding service can generate embeddings via OpenRouter and store in Supabase</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx tsc --noEmit` passes with no errors
- [ ] OpenRouterClient.embeddings() method exists and compiles
- [ ] chunkBlueprint() produces correct chunk structure
- [ ] storeChunksWithEmbeddings() compiles with correct types
- [ ] All imports resolve correctly
</verification>

<success_criteria>
- OpenRouterClient extended with embeddings method
- Chunking service converts blueprints to semantic chunks
- Embedding service generates and stores vectors in Supabase
- All TypeScript types are correct
- No compilation errors
</success_criteria>

<output>
After completion, create `.planning/phases/15-rag-foundation/15-02-SUMMARY.md`
</output>
