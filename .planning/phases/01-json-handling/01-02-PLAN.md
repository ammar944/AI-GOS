---
phase: 01-json-handling
plan: 02
type: execute
---

<objective>
Improve JSON extraction to handle edge cases and add repair for common malformations.

Purpose: Make JSON extraction more resilient to AI response variations (truncated responses, trailing text, malformed JSON).
Output: Enhanced `extractJSON()` function in `src/lib/openrouter/client.ts` with repair capabilities.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/codebase/STACK.md
@.planning/codebase/CONVENTIONS.md

@src/lib/openrouter/client.ts

**Known issues from PROJECT.md:**
- JSON parsing failures from malformed AI responses
- Truncated responses from timeout or token limits
- Extra text before/after JSON

**Existing extraction strategies in client.ts:**
1. Parse whole content directly
2. Content starts with { - find matching brace
3. Content starts with [ - find matching bracket
4. Extract from markdown code blocks
5. Find first { and extract balanced JSON
6. Find first [ and extract balanced JSON
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add JSON repair for common malformations</name>
  <files>src/lib/openrouter/client.ts</files>
  <action>
Add a new `repairJSON()` private method to OpenRouterClient that attempts to fix common JSON issues before parsing.

**Common malformations to repair:**
1. Trailing commas: `{"a": 1,}` → `{"a": 1}`
2. Missing closing braces/brackets: `{"a": 1` → `{"a": 1}`
3. Unescaped newlines in strings (common with AI)
4. Single quotes instead of double quotes
5. Truncated at end (incomplete value): `{"a": "hello...` → try to close

**Implementation:**
```typescript
private repairJSON(json: string): string {
  let repaired = json;

  // Remove trailing commas before closing braces/brackets
  repaired = repaired.replace(/,(\s*[}\]])/g, "$1");

  // Count braces/brackets to detect truncation
  const openBraces = (repaired.match(/{/g) || []).length;
  const closeBraces = (repaired.match(/}/g) || []).length;
  const openBrackets = (repaired.match(/\[/g) || []).length;
  const closeBrackets = (repaired.match(/]/g) || []).length;

  // Try to close truncated JSON
  // ... add closing braces/brackets as needed

  return repaired;
}
```

**Integration:**
- Call repairJSON() in extractJSON() after balanced extraction fails
- Only attempt repair as a fallback, not for all content
- Log when repair is applied for debugging
  </action>
  <verify>TypeScript compiles without errors: npx tsc --noEmit</verify>
  <done>repairJSON method exists, handles trailing commas and truncated JSON</done>
</task>

<task type="auto">
  <name>Task 2: Enhance extractJSON with truncation handling</name>
  <files>src/lib/openrouter/client.ts</files>
  <action>
Enhance the extractJSON() method to better handle truncated responses.

**Improvements:**
1. After all extraction strategies fail, try repairJSON() on the best candidate
2. Add a "greedy" extraction mode that takes partial JSON
3. Handle case where AI adds explanation after JSON block
4. Handle case where JSON is split across markdown blocks

**New extraction strategy order:**
1. Parse whole content directly (best case)
2. Content starts with { - find balanced JSON
3. Content starts with [ - find balanced array
4. Extract from markdown code blocks
5. Find first { or [ and extract balanced
6. **NEW:** Try repair on best balanced extraction attempt
7. **NEW:** Greedy extraction - find { or [ and take until last } or ]

**Code pattern for greedy extraction:**
```typescript
// Strategy 7: Greedy extraction (last resort)
const firstOpen = Math.min(
  trimmed.indexOf("{") === -1 ? Infinity : trimmed.indexOf("{"),
  trimmed.indexOf("[") === -1 ? Infinity : trimmed.indexOf("[")
);
if (firstOpen !== Infinity) {
  const lastClose = Math.max(trimmed.lastIndexOf("}"), trimmed.lastIndexOf("]"));
  if (lastClose > firstOpen) {
    const candidate = trimmed.slice(firstOpen, lastClose + 1);
    const repaired = this.repairJSON(candidate);
    if (this.isValidJSON(repaired)) {
      console.log("[JSON Extraction] Used greedy extraction with repair");
      return repaired;
    }
  }
}
```

**Logging:**
- Add console.log when repair succeeds
- Log which strategy succeeded for debugging
  </action>
  <verify>TypeScript compiles: npx tsc --noEmit</verify>
  <done>extractJSON handles truncation via repair and greedy extraction</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx tsc --noEmit` passes
- [ ] repairJSON method exists and handles trailing commas
- [ ] repairJSON handles truncated JSON (missing closing braces)
- [ ] extractJSON has greedy extraction as fallback
- [ ] Extraction logs which strategy succeeded
</verification>

<success_criteria>
- JSON repair handles common malformations
- Extraction has 7+ strategies including repair
- Code compiles without errors
- Ready for integration with validation
</success_criteria>

<output>
After completion, create `.planning/phases/01-json-handling/01-02-SUMMARY.md`
</output>
