---
phase: 01-json-handling
plan: 03
type: execute
---

<objective>
Integrate Zod validation into the AI response pipeline and return partial results on failure.

Purpose: Validate every AI response before accepting, provide clear error messages, and allow partial plan generation when later sections fail.
Output: Enhanced chatJSON with validation, updated media plan generator with partial result support.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/codebase/STACK.md
@.planning/codebase/CONVENTIONS.md

@.planning/phases/01-json-handling/01-01-SUMMARY.md
@.planning/phases/01-json-handling/01-02-SUMMARY.md

@src/lib/openrouter/client.ts
@src/lib/media-plan/schemas.ts
@src/lib/media-plan/pipeline/media-plan-generator.ts

**Prior plan outputs:**
- 01-01: Zod schemas for all 11 sections in schemas.ts
- 01-02: Enhanced extractJSON with repair capabilities
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add schema validation wrapper to chatJSON</name>
  <files>src/lib/openrouter/client.ts</files>
  <action>
Add a new `chatJSONValidated<T>()` method that validates responses against a Zod schema.

**Method signature:**
```typescript
async chatJSONValidated<T>(
  options: ChatCompletionOptions,
  schema: z.ZodType<T>,
  retries: number = 2
): Promise<{
  data: T;
  usage: ChatCompletionResponse["usage"];
  cost: number;
  validationErrors?: string[];
}>
```

**Implementation:**
1. Call existing chatJSON() to get parsed JSON
2. Validate against provided Zod schema using schema.safeParse()
3. If validation fails:
   - Log validation errors clearly
   - On retry, include validation errors in prompt to help AI fix
   - After all retries exhausted, throw with validation error details
4. Return validated and typed data

**Error handling:**
- Create descriptive error messages from Zod errors
- Format as: "Field 'executiveSummary.strategicPriorities' expected array, got string"

**Import required:**
- Add `import { z } from "zod"` at top of file
  </action>
  <verify>npx tsc --noEmit passes</verify>
  <done>chatJSONValidated method exists, validates against schema, returns typed data</done>
</task>

<task type="auto">
  <name>Task 2: Update media plan generator to use validated responses</name>
  <files>src/lib/media-plan/pipeline/media-plan-generator.ts</files>
  <action>
Update the generator to use chatJSONValidated with the appropriate schema for each section.

**Changes:**
1. Import schemas: `import { executiveSummarySchema, ... } from "../schemas"`
2. Create a section-to-schema mapping:
```typescript
const SECTION_SCHEMAS: Record<MediaPlanSection, z.ZodType<unknown>> = {
  executiveSummary: executiveSummarySchema,
  campaignObjectiveSelection: campaignObjectiveSelectionSchema,
  // ... all 11 sections
};
```

3. Update the generation loop to use chatJSONValidated:
```typescript
const schema = SECTION_SCHEMAS[section];
const response = await client.chatJSONValidated({
  model: MODELS.CLAUDE_SONNET,
  messages,
  temperature: 0.4,
  maxTokens: 4096,
}, schema);
```

4. Catch validation errors per-section to enable partial results (next task)
  </action>
  <verify>npx tsc --noEmit passes</verify>
  <done>Generator uses schema validation for each section, type-safe responses</done>
</task>

<task type="auto">
  <name>Task 3: Return partial results on section failure</name>
  <files>src/lib/media-plan/pipeline/media-plan-generator.ts</files>
  <action>
Update the generator to return partial results when later sections fail.

**Changes to MediaPlanGeneratorResult:**
```typescript
export interface MediaPlanGeneratorResult {
  success: boolean;
  mediaPlan?: MediaPlanOutput;
  partialPlan?: Partial<MediaPlanOutput>;  // NEW: partial result
  failedSection?: MediaPlanSection;        // NEW: which section failed
  error?: string;
  metadata: {
    totalTime: number;
    totalCost: number;
    sectionTimings: Record<string, number>;
    completedSections: MediaPlanSection[];  // NEW: track completed
  };
}
```

**Generation loop changes:**
1. Wrap each section generation in try/catch
2. On section failure:
   - Log the error with section context
   - Check if we have at least 3 completed sections (enough for partial value)
   - If yes: return success:false with partialPlan containing completed sections
   - If no: return full failure
3. Track which sections completed in metadata

**Partial result handling:**
```typescript
catch (sectionError) {
  console.error(`Section ${section} failed:`, sectionError);

  if (completedSections.length >= 3) {
    // Return partial result
    return {
      success: false,
      partialPlan: { ...partialOutput },
      failedSection: section,
      error: `Generation stopped at ${MEDIA_PLAN_SECTION_LABELS[section]}: ${sectionError.message}`,
      metadata: { ... }
    };
  }
  // Too early to return partial, propagate error
  throw sectionError;
}
```
  </action>
  <verify>npx tsc --noEmit passes</verify>
  <done>Generator returns partial results when sections fail, includes failure context</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx tsc --noEmit` passes
- [ ] chatJSONValidated method validates against Zod schemas
- [ ] Generator uses schemas for all 11 sections
- [ ] Partial results returned when later sections fail
- [ ] Failed section and error context included in result
</verification>

<success_criteria>
- All AI responses validated against Zod schemas
- Clear validation error messages
- Partial results supported (3+ sections minimum)
- No TypeScript errors
- Phase 1 objectives complete
</success_criteria>

<output>
After completion, create `.planning/phases/01-json-handling/01-03-SUMMARY.md`

Include in summary:
- All Phase 1 objectives completed
- Ready for Phase 2 (Timeout and Retry Logic)
</output>
