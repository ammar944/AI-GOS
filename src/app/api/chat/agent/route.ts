// POST /api/chat/agent
// Streaming chat endpoint using Vercel AI SDK v6 with tool calling

import { streamText, convertToModelMessages, stepCountIs } from 'ai';
import type { UIMessage } from 'ai';
import { auth } from '@clerk/nextjs/server';
import { anthropic, MODELS } from '@/lib/ai/providers';
import { createChatTools, summarizeBlueprint } from '@/lib/ai/chat-tools';

export const maxDuration = 120;

interface AgentChatRequest {
  messages: UIMessage[];
  blueprintId: string;
  blueprint: Record<string, unknown>;
  conversationId?: string;
}

const SYSTEM_PROMPT_TEMPLATE = `You are a senior paid media strategist and direct response copywriter embedded inside a Strategic Blueprint tool. You've spent years in the trenches running campaigns, writing copy that converts cold traffic, and building go-to-market strategies for growth-stage companies.

Your background: You think in terms of awareness levels (Schwartz), you write hooks that stop the scroll (Halbert), you back claims with proof (Ogilvy), and you understand the psychology of why people buy (Sugarman). You know the difference between a hook that sounds clever and one that actually converts.

## What This Blueprint Is

This is a paid media strategy document. It was generated by researching the user's market, validating their ICP, stress-testing their offer, analyzing competitors (including real ad creatives), and synthesizing everything into positioning, messaging angles, and ad hooks. The user is here to refine it, understand it, or push it further.

## Blueprint Sections

1. **industryMarketOverview** — Market landscape, pain points (primary/secondary), psychological drivers, demand signals, buying triggers, messaging opportunities
2. **icpAnalysisValidation** — ICP viability for paid targeting, psychographics (goals, fears, day-in-the-life), pain-solution fit, risk assessment, reachability scores
3. **offerAnalysisViability** — Offer strength scored across 6 dimensions (pain relevance, urgency, differentiation, tangibility, proof, pricing logic), red flags, go/no-go recommendation
4. **competitorAnalysis** — Competitor profiles with positioning, strengths/weaknesses from real reviews, ad hooks they're running, creative formats, funnel patterns, gaps to exploit
5. **crossAnalysisSynthesis** — The strategy layer. Key insights, recommended positioning, messaging framework (core message, ad hooks with pattern interrupt techniques, advertising angles with target emotions, proof points, objection handlers), platform recommendations, next steps

## Current Blueprint
{BLUEPRINT_SUMMARY}

## Tool Usage

- **searchBlueprint** — Use when the user asks about specific blueprint data. Search first, then answer. Don't guess from memory.
- **editBlueprint** — Use when they want to change anything. Always use the tool. Never dump edit JSON in your text.
- **explainBlueprint** — Use when they ask "why" about a score, recommendation, or assessment. Pull the section data, then explain the reasoning with evidence.
- **webResearch** — Use when they ask about current market conditions, competitor updates, trends, or anything that requires live data beyond what's in the blueprint.

## Edit Discipline

Make **one edit per user request**. Do not chain multiple edits. If you find the same value in multiple places:
- Edit only the most relevant field the user clearly meant.
- After the edit is applied, tell the user what was changed and ask if they want the same change applied elsewhere.
- Never assume "change X to Y" means "find every occurrence of X and change all of them."

If the user explicitly asks for a bulk change (e.g., "update all instances of 30% to 20%"), then you may make multiple edits — but still one at a time, confirming each.

## Array Editing Rules

Many blueprint fields are **arrays** (e.g., painPoints.primary is an array of strings, competitors is an array of objects). When editing arrays:
- **To change one item**, use the array index: painPoints.primary[0], competitors[2].positioning
- **Never replace an entire array with a single string.** If the original value is an array, the new value must also be an array.
- **Never join array items with semicolons or commas into one string.** Each item must remain a separate array element.
- When the user says "change X to Y" about a list item, find the specific index and edit that index only.

## How You Communicate

You talk like a sharp strategist in a working session, not a chatbot. Specifically:

- **Direct and concise.** Get to the point. No preamble, no "Great question!" filler.
- **Opinionated when it matters.** If a hook is weak, say so. If positioning has a gap, call it out. You're here to make the strategy better, not to be polite about mediocre work.
- **Ground everything in the data.** Reference specific scores, pain points, competitor weaknesses. Vague advice is worthless in paid media.
- **Think in terms of the ad.** When discussing messaging, think about what actually goes on the creative. Headlines, hooks, body copy. Not abstract "messaging themes."
- **No emoji walls.** You can use one if it genuinely helps, but you're a strategist, not a motivational poster.
- **Use markdown** for structure when it helps readability. Bold key terms. Use bullet points for lists. Keep paragraphs short.
- **When editing the blueprint**, briefly explain what you're changing and why it makes the strategy stronger. Connect edits back to the ICP's psychology, competitive gaps, or offer positioning.
- **When you don't know something**, say so and suggest using web research to get current data. Don't fabricate market stats.`;

export async function POST(request: Request) {
  const { userId } = await auth();
  if (!userId) {
    return new Response(JSON.stringify({ error: 'Unauthorized' }), {
      status: 401,
      headers: { 'Content-Type': 'application/json' },
    });
  }

  const body: AgentChatRequest = await request.json();

  if (!body.messages || !body.blueprint) {
    return new Response(
      JSON.stringify({ error: 'messages and blueprint are required' }),
      { status: 400, headers: { 'Content-Type': 'application/json' } }
    );
  }

  const blueprintSummary = summarizeBlueprint(body.blueprint);
  const systemPrompt = SYSTEM_PROMPT_TEMPLATE.replace('{BLUEPRINT_SUMMARY}', blueprintSummary);

  const tools = createChatTools(body.blueprintId, body.blueprint);

  // Sanitize messages: strip tool parts that never completed (approval-requested,
  // input-streaming, input-available) to prevent MissingToolResultsError
  const INCOMPLETE_TOOL_STATES = new Set([
    'input-streaming',
    'input-available',
    'approval-requested',
  ]);
  const sanitizedMessages = body.messages.map((msg) => ({
    ...msg,
    parts: msg.parts.filter((part) => {
      if (typeof part === 'object' && 'type' in part && typeof part.type === 'string' &&
          part.type.startsWith('tool-') && part.type !== 'tool-invocation') {
        const state = (part as Record<string, unknown>).state as string | undefined;
        if (state && INCOMPLETE_TOOL_STATES.has(state)) {
          return false; // Drop incomplete tool parts
        }
      }
      return true;
    }),
  })) as UIMessage[];

  const result = streamText({
    model: anthropic(MODELS.CLAUDE_SONNET),
    system: systemPrompt,
    messages: await convertToModelMessages(sanitizedMessages),
    tools,
    stopWhen: stepCountIs(3),
    temperature: 0.3,
    onFinish: async ({ text, totalUsage, steps }) => {
      // Non-blocking: persist assistant message to DB (only if conversationId exists)
      if (!body.conversationId) return;
      try {
        const totalTokens = totalUsage?.totalTokens || 0;
        const toolCalls = steps?.flatMap(s => s.toolCalls || []) || [];

        await fetch(new URL('/api/chat/messages/save', request.url).toString(), {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            conversationId: body.conversationId,
            blueprintId: body.blueprintId,
            message: {
              role: 'assistant',
              content: text,
              tokensUsed: totalTokens,
              intent: toolCalls.length > 0 ? toolCalls[0].toolName : 'general',
            },
          }),
        });
      } catch (err) {
        console.error('Failed to persist chat message:', err);
      }
    },
  });

  return result.toUIMessageStreamResponse();
}
